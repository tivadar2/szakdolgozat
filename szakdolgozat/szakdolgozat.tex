\documentclass[12pt]{article}
\usepackage[a4paper]{geometry}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{t1enc}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{caption}
\usepackage{cleveref}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{diagbox}
\usepackage{setspace}
\usepackage[square,numbers]{natbib}
\bibliographystyle{unsrt}
%\usepackage[backend=biber]{biblatex}
%\addbibresource{bibliography.bib}

\begin{document}

% TODO: komplexitásszerű dolgok leírása, hányszor kell fitness-t számolni, a különböző módszereknél
% TODO: margók

\begin{titlepage}
	\centering
	{\Huge\bfseries Szakdolgozat\par}
	\vspace{1cm}
	\vspace{1cm}
	{\LARGE Optimalizációs módszerek alkalmazása
		az életkorbecslés problémára \par}
	\vspace{3cm}
	{\huge\bfseries Pongó Tivadar\\\par}
	\vspace{3cm}
	\begin{table}[H]
		\centering
		\begin{tabular}{ccl}
			&	\LARGE\textbf{Témavezető:} &\Large Dr. Török János \\
			& &\\
			& &\Large egyetemi docens \\
			& &\\
			& &\Large BME Elméleti Fizika Tanszék \\
			
		\end{tabular}
		\caption*{}
		\label{t1}
	\end{table}
	\vfill
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.35]{img/bme_logo_kicsi.eps}
	\end{figure} 
	{\large Budapesti Műszaki és Gazdaságtudományi Egyetem\\ 2017 \par}
\end{titlepage}
\onehalfspacing
\iffalse
\section*{Szakdolgozat}
\begin{itemize}
	\item a TDK alapján megírtam a programot, ebből mennyit kell majd leírnom szakdolgozatba?
	\item időzabáló rész a gauss görbe a konvolúciónál (maga a konvolúció elég sok idő) 20-30 s egy futás a kb. 11000 ego-ra + gauss optimalizálása listával
	\item Gradiens módszer egy és több dimenzióban
	\begin{itemize}
		\item "zajos" a pm2 függvény, emiatt derivált számolásnál nagy "dx"-et kell választani -> ábra majd
		\item gamma helyes megválasztása, konstans vagy függ a gradienstől (a konstans működött)
		\item először az $\dfrac{1}{s + \sigma}$ súlyt próbáltam, ahol s a paraméter, $\sigma$ pedig a csoport életkorainak szórása
		\item 3 felé osztottam a csoport életkorainak szórása alapján a súlyfaktort 3 alatt, 3 és 6 közt és 6 felett, így futtatva a gradiens módszert a 6 feletti szórások súlyára negatívat kaptam -> lehet, hogy így több csúcs lesz a negatív súly miatt?
	\end{itemize}
	\item Simulated annealing
	\item genetikus algoritmus
\end{itemize}
pm2 függvény - plusz mínusz 2 éven belüli becslések aránya, 0 és 1 közti szám \\ \\
\fi


\pagebreak
% Önállósági nyilatkozat
\begin{center}
	{\Huge Önállósági nyilatkozat}
\end{center}
\medskip
Alulírott Pongó Tivadar a Budapesti Műszaki és Gazdaságtudományi Egyetem fizika BSc szakos hallgatója kijelentem, hogy ezt a szakdolgozatot meg nem engedett segédeszközök nélkül, önállóan, a témavezető irányításával készítettem, és csak a megadott forrásokat használtam fel. \\
Minden olyan részt, melyet szó szerint, vagy azonos értelemben, de átfogalmazva más forrásból vettem, a forrás megadásával jelöltem.\\\\
Budapest, 2017. 05. 26. \\ \\ \\ %TODO: Dátum pontosan
\hspace*{100mm}aláírás % TODO: ide nevet szoktak?
\pagenumbering{gobble}
\pagebreak
\tableofcontents
\pagebreak
\section{Bevezetés}
\pagenumbering{arabic}
Napjainkban a felgyorsult információáramlás miatt rengeteg adat keletkezik rólunk, illetve környezetünkről az interneten.
Hétköznapi tevékenységeink során digitális nyomot hagyunk magunk után a néhány éve, évtizede létrejött információ- és kommunikációtechnológia alapú környezetekben.
A különböző csatornákon folytatott kommunikációnk, pénzügyi tevékenységeink, a mobiltelefon szolgáltatónk által ismert fizikai elhelyezkedésünk stb., mind felvételre kerül.
Ezen a sok passzívan gyűjtött adaton kívül gyakran aktívan is osztunk meg információkat érzéseinkről, hangulatunkról, véleményünkről és nézeteinkről.
Azon kívül, hogy újszerű módon kaphatunk válaszokat az emberek szociális életét érintő klasszikus kérdésekre tudományos szempontból, ennek a hatalmas mennyiségű adat vizsgálatának hasznos alkalmazásai lehetnek. A feldolgozás után előrejelzéseket, becsléseket tehetünk különböző eseményekre a mindennapi életünk egyszerű ügyeitől kezdve akár globális méretű krízisekre is.
Például fejlesztettek ki már olyan jelzőrendszert, mely tweeteket (a Twitter mikroblog szolgáltatás bejegyzései) használ fel földrengések észlelésére szinte valós időben \cite{sakaki2010earthquake}.
Később kiegészítették a jelzőrendszerüket, úgy hogy szivárványok és városi dugók észlelésére is alkalmas legyen \cite{sakaki2013tweet}. Munkájuk gyakorlati jelentősége abban mutatkozik meg, hogy a jelzőrendszer olyan gyorsan reagálhat, hogy a jelzés előbb megérkezhet, mint a földrengés hullámai bizonyos területeken.
Másik példa a Twitter bejegyzéseket használatára a választások eredményének jóslása \cite{tumasjan2010predicting}, melynek persze vannak határai \cite{gayo2011limits, gayo2012wanted}.
Ginsberg és munkatársai megbecsülték az influenza terjedését az Egyesült Államokban \cite{ginsberg2009detecting}. Vannak egyéb példák is a szociális média felhasználására, hogy előrejelezzék hírek népszerűségét, a felhasználók által írt megjegyzések számában \cite{tsagkias2009predicting, tsagkias2010news} vagy a hírmegtekintések számában \cite{castillo2014characterizing} mérve.
\cite{bigData_wikipedia}

A szakdolgozatomban egy életkorbecslő módszert mutatok be, mely ugyanúgy sok adat feldolgozásán alapszik. A becslés az ember kapcsolati hálózata és az ismerősök életkorai alapján történik, és közel sem triviális. A fizikusok foglalkoznak komplex rendszerek vizsgálatával, ezáltal a szociális hálózatok tanulmányozása is érdekes feladatnak bizonyul számunkra. A célom a becslő módszer javítása gépi optimalizációs módszerekkel, ez manapság a mesterséges intelligencia terjedésével egy felkapott kutatási terület. % TODO: hivatkozás a 10%-ra?
% Az adatok egy része egy telefonszolgáltatótól, a másik része az egykori magyar közösségi oldal, iWiW természetesen névtelenül.
% TODO: én mit akarok ezzel csinálni (optimalizáció)
% TODO: komplex rendszer, tehát fizikával összehasonlítható
% TODO: erre akarok egy programot írni

\section{Az életkorbecslő eljárás}
Az életkor meghatározásához alapvetően az adott illető egocentrikus hálózatát használjuk fel, ez a szociális hálózatnak azon része, amelyben már csak az ő ismerősei vannak jelen. Az egocentrikus hálózat egy gráf, melynek csúcsai az ismerősök, illetve a vizsgált személy, az élek pedig az ismeretségeket jelölik. A rendelkezésünkre álló adatbázisban a kapcsolatrendszereken kívül az emberek életkorai is adottak, bár lehetnek rosszak vagy hiányosak az adatok. Ezen információk alapján becsüljük meg egy ember életkorát a következő részben leírtak szerint.
%Az életkor meghatározásához alapvetően egy szociális hálózatot használunk fel. Ezen belül úgynevezett egocentrikus hálózatot, amely már csak egy adott személy kapcsolatrendszerét tartalmazza. Az adatbázisban a kapcsolatok mellett az ismerősök életkorait tartalmazzák. Persze ezek az adatok hiányosak, vagy lehetnek hibásak is. A kapcsolati hálózat egy gráfként kezelhető, amelyben a csúcsok az embereknek, az élek pedig a köztük lévő ismeretségnek felelnek meg.

% TODO: adatbázisok 
\subsection{Optimizálatlan életkor-meghatározás} \label{eletkor_becsles_tamas_gabor}
Ebben az alrészben a \cite{tamas_gabor_tdk} TDK dolgozatban leírt életkorbecslő eljárást ismertetem, amely alapul szolgál ezen szakdolgozatnak.

%Az embereket jól jellemzik a közösségek, amelyeknek tagjai. Ilyenek például az osztályok, a családok, a munkatársi vagy baráti körök. Egy kiválasztott egyén életkora összefüggésbe hozható a közösségei átlagéletkoraival. Ez az összefüggés nem triviális, viszont felhasználható a vizsgált személy korának meghatározásához. 
Az emberek közösségekben élik életüket, mely lehet munkahely, baráti kör, család, hobbi, stb. Ezen közösségek jellemzője, hogy a tagjaikat valami összeköti, közös érdeklődés, tevékenység stb. Nagyon sok féle homofília lehet az emberek között, de ezek közül a legtermészetesebb az életkor, hiszen kortársainkkal vagyunk általában azonos élethelyzetben, azonosak a problémáink. Az egyének szociális kapcsolatrendszerét az egocentrikus hálózattal tudjuk jellemezni (pl. \ref{egocentrikus}. ábra), amelyben viszonylag természetesen jelennek meg a közösségek.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{img/ccmy.png}
	\caption{Egy egocentrikus hálózat} % TODO: aláírás
	\label{egocentrikus}
\end{figure}
A pusztán hálózati megközelítés azonban nem ad számot arról, hogy egy adott közösség milyen konkrét társadalmi igény köré szerveződik. Azonban várható, hogy felülreprezentáltak lesznek az egyénnel azonos korösszetételű közösségek.
Feladatunk tehát, hogy először feltérképezzük a közösségeket a hálózatban, ami nem egyértelmű feladat. Létezik \iffalse TODO: létezik helyett valami más szó \fi többfajta közösségfelismerő algoritmus, melyek megpróbálják az ember által elképzelt közösségképet felhasználni a kereséshez, illetve a hálózat esetleges hibáit is figyelembe venni (például hiányzó élek vagy csúcsok). Az általunk továbbiakban használt csoportok az úgynevezett Ahn-módszerrel \cite{tamas_gabor_tdk} \iffalse TODO: kell ez? \fi lettek feltérképezve. % TODO: vagy másik cikk

Ezután készítettünk egy Gauss-függvénnyel \eqref{simito_gauss} simított hisztogramot, amit az életkoráloszlás ugyanolyan Gauss-függvénnyel simított függvényével normáltunk \eqref{diszkret_konv}:
%Ezután készítünk egy hisztogramot, még pedig úgy, hogy a csoportok átlagéletkoraira centrált Gauss-görbéket összegezzük az összes csoportra, tehát egy diszkrét konvolúciót végzünk el \eqref{diszkret_konv}.
\begin{equation} \label{simito_gauss}
	g(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^2}{2\sigma^2}}
\end{equation}
\begin{equation} \label{diszkret_konv}
	K(a) = \frac{1}{n_{sm}(a)}\sum_{i=1}^{C} g(a-a_i) \cdot s(n_{i}, \sigma_{i}) % illetve a simított életkoreloszlással való leosztás
\end{equation} % TODO: miért kell a simítás, egy-egy egyénre lehet, hogy nem az a jó, mint az összesre, 
\Aref{simito_gauss}. képlet egy normált Gauss-függvény, amelynek a szórásparamétere $\sigma$. A diszkrét konvolúcióban \eqref{diszkret_konv} $a$ az életkort jelöli, $C$ a csoportok számát, $a_i$ az i. csoport átlagéletkorát, $s$ pedig egy súlyfaktort, amely függhet az adott csoport nagyságától ($n_{i}$) és a csoporton belüli életkorok szórásától ($\sigma_i$).

A legegyszerűbb eset, amikor $s\equiv 1$, ekkor nem vesszük figyelembe a csoportok tulajdonságait.
A szumma előtti $n_{sm}$ egy normált, simított életkoreloszlás függvény, amellyel azért osztunk le, hogy kompenzáljuk a középkorúak felülreprezentáltságát a hálózatban.
A simításhoz használt Gauss-függvény szórását \acite{tamas_gabor_tdk} TDK munkában $\sigma=2$-nek választották. \Aref{hisztogram_pelda}. ábrán láthatunk egy példát a $K(a)$ függvényre. A függvényt csak egész évű pontokban értékeltük ki.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/82152624_age47.eps}
	\caption{Példa hisztogram} % TODO: bővebb aláírás kell?
	\label{hisztogram_pelda}
\end{figure}
A hisztogramokon csúcsok találhatóak, amelyek azt jelentik, hogy több csoportban ugyanaz az átlagéletkor. Minél nagyobb a csúcs, annál több ilyen csoport van. Ez alapján a vizsgált személy életkorát a legmagasabb csúcs helyével becsülhetnénk. Azonban nem mindegyik hisztogram olyan egyszerű, mint \aref{hisztogram_pelda}. ábrán látható, sokszor több csúcs hasonló nagyságú, ekkor érdemes figyelembe venni a csúcsok félértékszélességét. Definiálhatunk egy csúcs jósági tényezőt \aref{csucs_josag}. képlet szerint:
\begin{equation} \label{csucs_josag}
	v = \frac{h}{w},
\end{equation}
ahol $h$ a csúcs magassága, $w$ a csúcs félértékszélessége. Tehát minél magasabb és minél keskenyebb egy csúcs, annál jobb. Ezek után a program sorba rendezi a csúcsokat $v$ szerint és a legnagyobb $v$ értékkel rendelkezőt választja becsült életkornak.

Gyakran előfordul olyan, hogy két nagyobb csúcs is jelen van körülbelül 20-25 év távolságra egymástól, ezek valószínűleg két generációt jellemeznek, a szülőket és gyereküket. Egy ilyen esetre láthatunk példát \aref{generaciok}. ábrán.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/generaciok.eps}
	\caption{Generációk megfigyelése hisztogramon, a két fő csúcs távolsága 24 év}
	\label{generaciok}
\end{figure}

\iffalse
Azt is meg kell említenünk, hogy a hisztogram simítása miatt a csúcs helye eltolódhat, ha a csúcs egyik oldalán sokkal több csoport van, mint a másikon.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/}
\end{figure}
\fi
\subsection{Paraméterek a becslés során} \label{parameterek_subsection}
Az életkor meghatározása során használunk különböző paramétereket, ilyenek például a Gauss-függvényben \eqref{simito_gauss} a $\sigma$\iffalse TODO: na jó nem biztos, hogy így szép \fi, illetve \aref{diszkret_konv}. képletben lévő $s(n_i, \sigma_i)$-ből származtatott paraméterek. \Acite{tamas_gabor_tdk} munkában $\sigma=2$, $s=1$ választást használjuk kiindulópontnak, és
ezt optimalizálatlan esetnek nevezzük.

Többféleképpen is lehet definiálni paramétereket. Feloszthatjuk az $(n_i, \sigma_i)$ teret tartományokra és az egyes tartományokon alkalmazott súlyok lesznek a paraméterek. A felosztást \aref{felosztas}. táblázat szerint végeztem, ebben külön vettem a $\sigma_{cs} = 0$ esetet.
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\diagbox{$\sigma_{cs}$}{$n_{cs}$} & $]0;1]$ & $]1;5]$ & $]5;10]$ & $]10;\infty[$  \\
		\hline
		$0$ & $p_{10}$ & \multicolumn{3}{|c|}{$p_{11}$} \\
		\hline
		$]0;3]$ & \multicolumn{2}{|c|}{$p_1$} & $p_2$ & $p_3$ \\
		\hline
		$]3;6]$ & \multicolumn{2}{|c|}{$p_4$} & $p_5$ & $p_6$ \\
		\hline
		$]6;\infty[$  & \multicolumn{2}{|c|}{$p_7$} & $p_8$ & $p_9$ \\
		\hline
	\end{tabular}
	\caption{A különböző tartományokban alkalmazott súlyok}
	\label{felosztas}
\end{table}
\noindent
A 12. paraméter pedig $p_{12} \equiv \sigma$, azaz a hisztogramsimítás erőssége. A $\sigma_{cs} = 0$ eset külön vételére azért van szükség, mert nagyon sok csoportban csak egy embernek ismert az életkora, emiatt annak a szórása $0$. Az $n_{cs}$ ebben az esetben nem a tényleges csoport méret, hanem azoknak az embereknek a száma, akiknek ismert az életkora a csoportban, a vizsgált személyt nem számolva.
A fenti a paraméterek egy $\mathbf{p} = (p_1, p_2, ..., p_{12})$ vektorba rendezhetőek.

A paraméterek fentebb leírt módon való kiválasztása, azért is jó, mert a csoportméretet és a csoportszórást nem csak egymástól függetlenül tudjuk súlyozni, azaz $s(n_i, \sigma_i) \neq s'(n_i)\cdot s''(\sigma_i)$. Ezáltal például megkülönböztethetünk egy osztályt egy munkatársakból álló csoporttól. A csoportméret a kettőnél ugyanúgy nagy lehet, viszont az előbbinek a csoportszórása kisebb, ezért azt gondoljuk, hogy azt nagyobb súllyal kell figyelembe venni.
\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\includegraphics[scale=0.5]{img/group_sizes.eps}
		\caption{Csoportok száma a csoportméret ($n_{cs}$) függvényében a különböző ismerősszámú hálózatok esetében}
	\end{subfigure} \hfill
	\begin{subfigure}{0.49\textwidth}
		\includegraphics[scale=0.5]{img/group_devs.eps}
		\caption{Csoportok száma a csoportszórás ($\sigma_{cs}$) függvényében a különböző ismerősszámú hálózatok esetében}
	\end{subfigure}
	\caption{Csoportok méret- és szóráseloszlásai}
	\label{meret_szoras_eloszlas}
\end{figure}
Abban, hogy a paraméterek határait hol húzzuk meg \aref{meret_szoras_eloszlas}. ábra segített. Megpróbáltunk jellegzetes tartományokat kiválasztani, ebből lett \aref{felosztas}. táblázat szerinti felosztás. Emellett nem szerettünk volna sok paramétert se, mert az optimalizálásnál az nem előnyös.

Egy másik lehetőség a súlyfaktor választására, ha $s(n_i, \sigma_i)$ valamilyen matematikai függvény. Például kipróbáltuk a \eqref{masik_suly} szerinti összefüggést is.
\begin{equation} \label{masik_suly}
	s(n_i, \sigma_i) = \frac{1}{p + \sigma_i}
\end{equation}
Ez a súly független a csoport méretétől és csak egy paramétert tartalmaz, a $p$-t. Illetve egyszerűen veszi figyelembe a csoport szórását, ha az kicsi, akkor nagyobb a súly, ellenkező esetben kisebb. A paraméter állításával pedig a súly csoportszórásra való érzékenységét lehet könnyen változtatni. Viszont a tartományok felosztását használtuk a már fentebb említett előnyei miatt.
% TODO: negatív paraméterek?

\subsection{Sikerességi ráták}
Ha a becslés pontosságát, sikerességét számokban akarjuk kifejezni, akkor a valódi és a becsült életkor közötti különbséget használhatjuk fel. A becslést elvégezzük az összes személyre, akinek tudjuk az életkorát, majd megnézzük, hogy a becslések hány százalékában volt a becsült és a valós korok közti eltérés $\pm 1, 2,3,4,5$ év. Optimalizálatlan esetben a sikerességek \aref{telefon_sikeresseg_nemopt}. és \aref{iwiw_sikeresseg_nemopt}. táblázatban foglaltak szerint alakulnak.
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{tabular}{|c|c|}
		\hline
		Hiba (év) & Ismerősszám: 60-69 \\
		\hline
		$\pm 1$ & 22,7 \% \\
		\hline
		$\pm 2$ & 35,4 \% \\
		\hline
		$\pm 3$ & 45,0 \% \\
		\hline
		$\pm 4$ & 52,2 \% \\
		\hline
		$\pm 5$ & 57,8 \% \\
		\hline
	\end{tabular}
	\caption{Sikerességek a telefonos adatok esetében}
	\label{telefon_sikeresseg_nemopt} % TODO: átírni ezeket, mert koreloszlással leosztás
\end{table}
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\multirow{2}{*}{Hiba (év)} & \multicolumn{4}{|c|}{Ismerősszám} \\ \cline{2-5} & 50 & 100 & 200 & 300 \\
		\hline
		$\pm 1$ & 41,0 \% & 53,3 \% & 65,3 \% & 68,7 \% \\
		\hline
		$\pm 2$ & 50,6 \% & 63,8 \% & 77,5 \% & 81,9 \% \\
		\hline
		$\pm 3$ & 56,4 \% & 68,3 \% & 81,8 \% & 85,9 \% \\
		\hline
		$\pm 4$ & 59,8 \% & 70,9 \% & 84,1 \% & 88,0 \% \\
		\hline
		$\pm 5$ & 62,9 \% & 72,9 \% & 85,7 \% & 89,4 \% \\
		\hline
	\end{tabular}
	\caption{Sikerességek az iWiW-es adatok esetében}
	\label{iwiw_sikeresseg_nemopt}
\end{table}
A sikerességet a továbbiakban a $\pm 2$ éven belüli becslések hányadosának vesszük. A későbbiekben erre a hibahatárra fogunk optimalizálni, ezért el is nevezzük $E(\mathbf{p})$-nek a $\pm 2$ éven belüli sikerességet, amely egy $0$ és $1$ közötti szám.
% TODO: miért jobbak az iwiw-esek?
\subsection{Kiértékelési idő}
Az $E(\mathbf{p})$ függvény kiértékelési ideje nagyon fontos az optimizálás gyorsasága szempontjából, hiszen $E(\mathbf{p})$ kiszámolása alapvető eleme az összes módszernek. Az életkorbecslő eljárás legtöbb processzoridőt használó része a diszkrét konvolúció \eqref{diszkret_konv}. Ezt ahelyett, hogy ciklussal számoltuk volna, vektorizáltuk. Ennek következtében a számítógép sokkal gyorsabban ki tudja értékelni a $K(a)$ függvényt. Ezen alapszik a fizikusok köreiben is gyakran használt MATLAB programnyelv gyorsasága is. % TODO: jó ez így? ennyit írni az optimalizációról? esetleg: Ezen -> vektorizáláson

A hisztogram kiszámolásának ideje leginkább a csoportok számától függ, ezért az összes csoport száma arányos lesz a kiértékelési idővel.
\Aref{csoport_kiertekeles}. táblázatban foglaljuk össze az egyes adatbázisokhoz tartozó kiértékelési időket.
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{subtable}{1.0\textwidth}
		\centering
		\begin{tabular}{|c|c|c|c|}
			\hline
			& Telefonos (60-69) & iWiW (50) & iWiW (100)  \\
			\hline
			Egok száma & 11026 & 5006 & 6668 \\
			\hline
			Egy ego átlagos csoportszáma & 27,0 & 26,4 & 83,8 \\
			\hline
			Összes csoport száma & 297601 & 132165 & 558790 \\
			\hline
			Kiértékelési idő (s) & 6,44 & 2,95 & 11,3\\
			\hline
		\end{tabular}
		\caption{}
		\label{}
	\end{subtable}
	\newline
	\vspace*{0.5cm} % TODO: kell ez?
	\newline
	\begin{subtable}{1.0\textwidth}
		\centering
		\begin{tabular}{|c|c|c|}
			\hline
			& iWiW (200) & iWiW (300)  \\
			\hline
			Egok száma & 5652 & 4227 \\
			\hline
			Egy ego átlagos csoportszáma & 258,6 & 486,1 \\
			\hline
			Összes csoport száma & 1461378 & 2054883 \\
			\hline
			Kiértékelési idő (s) & 29,2 & 46,7 \\
			\hline
		\end{tabular}
		\caption{}
		\label{}
	\end{subtable}
	\caption{A különböző adatbázisokhoz tartozó adatok és a sikerességi függvény kiértékelési ideje, zárójelben pedig az ismerősszámok}
	\label{csoport_kiertekeles}
\end{table}

\section{Optimalizációs módszerek}
Egyszerű esetben az optimalizáció egy függvény minimum- vagy maximumhelyének megkeresését jelenti egy bizonyos tartományon \cite{Holder}. Ez azért lehet nehéz feladat, mert a függvényt kiértékelni egy pontban sokáig tarthat. Nagyon sok idő lenne az értelmezési tartomány egészére kiértékelni a függvényt.

Ebben a fejezetben különböző optimalizációs módszerek alapját próbáltam ki azzal a céllal, hogy az $E(\mathbf{p})$ függvényt maximalizáljam, tehát az életkorbecslés ($\pm 2$ éven belüli) sikerességi hányadosát növeljem.
\subsection{Gradiens módszer}
% https://en.wikipedia.org/wiki/Gradient_descent
A gradiens módszer \cite{gradient1, gradient2} egy elsőrendű iterációs optimalizációs algoritmus. Adott egy $\mathbf{x_0}$ kezdőpont és egy $F(\mathbf{x})$ függvény, amelyet maximalizálni\footnote{megjegyzés: minimalizálásra is használható a módszer} szeretnénk. A módszer lényege, hogy a kezdőpontban kiszámoljuk $F(\mathbf{x})$ gradiensét, majd ennek irányába mozdulunk el, úgy hogy az elmozdulás nagysága arányos $\nabla F(\mathbf{x})$-el.
Az algoritmust úgy folytatjuk, hogy az elmozdulás utáni pontot vesszük kezdőpontnak és az előzőeket újra elvégezzük.
Így a következő rekurzióval írható le a módszer:
\begin{equation}
	\mathbf {x}_{n+1}=\mathbf {x}_{n}+\gamma\nabla F(\mathbf {x}_{n}),\ n\geq 0,
\end{equation}
ahol $n$ az iterációszám, $\gamma$ egy konstans, mely függhetne $n$-től, de ezt most nem használjuk ki. 

Elsőrendűnek nevezzük az algoritmust, mert a gradiens csak a függvény első parciális deriváltjait tartalmazza. Emiatt az algoritmus egyszerű, de gyors. Látható, hogyha $\gamma$ elég kicsi, akkor minden lépés után közelebb kerülünk egy lokális maximumhoz, ezt szemlélteti \aref{grad_contour}. ábra is.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{img/Gradient_descent.eps}
	\caption{A gradiens módszer szemléltetése szintvonalak segítségével (forrás: \cite{grad_wiki})}
	\label{grad_contour}
\end{figure}

Esetünkben $F \equiv E$, amelyet a $\mathbf{p}$ paraméterek terén értelmezünk. A deriválást is máshogy kell értelmeznünk, mert egyrészt numerikus számítást kell végezni, tehát a deriváltat a következőképpen közelíthetjük:
\begin{equation}
	\frac{\partial f(x)}{\partial x} \approx \frac{f(x+\Delta x) - f(x)}{\Delta x},
\end{equation}
ahol $\Delta x = 0,5$-nek választottuk. Ennek az az oka, hogy a sikeresség függvény nem sima, lehetnek benne kis lokális minimumok, mint az \aref{E_param1}. ábrán is látható. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/E_param0.eps}
	\caption{Sikeresség a $p_1$ függvényében, a többi paraméter rögzített (iWiW 200 ismerős)}
	\label{E_param1}
\end{figure}
A $\Delta x$ ilyen nagy értékűnek választása esetén nem lehet nagy pontossággal meghatározni a lokális maximum helyét, ehelyett a függvény trendjét vesszük vele figyelembe, nem pedig a kis változásokat. Az hogy egy paraméter mekkora mértékű megváltoztatásával érünk egy kimutathatóan jobb sikerességet függ attól, hogy melyik paramétert változtatjuk, ezért a $\Delta x$-et minden paraméterre lehetne külön definiálni, ettől viszont az egyszerűség kedvéért eltekintünk.

Mivel az optimalizálandó függvényünk nem sima, ezért a megállási feltétel sem egyértelmű, lehet, hogy egy lépés után csak egy kis lokális minimumba kerültünk, de az is lehet, hogy már a nagyobb lokális maximumról haladunk lefelé.
Az algoritmus determinisztikus, azaz ha egy adott helyről többször elindítjuk azonos beállítások mellett, akkor mindig ugyanazt az utat teszi meg, illetve a végső paraméterek is ugyanazok lesznek.
\subsection{Szimulált hűtés}
A szimulált hűtés (angolul: simulated annealing) \cite{simulated_annealing} egy sztochasztikus optimalizációs módszer, mely a nevét a fémmegmunkálásban alkalmazott technikáról kapta, amely során a fémet felmelegítik, majd lassan lehűtik, ezzel megnövelve benne a kristályok méretét és csökkentve a hibákat.

Először definiálnunk kell egy hőmérsékletszerű paramétert, melyet $T$-vel jelölünk. Ezek után az algoritmus a következő lépésekkel írható le:
\begin{enumerate} %\setlength\itemsep{1em}
	\item Kezdőpont ($\mathbf{x}_0$) és hőmérséklet ($T$) választása
	\item Véletlenszerű közeli pont választása ($\mathbf{x}$) \label{veletlen_kozeli_pont}
	\item \begin{itemize} % TODO: érthető-e?
		\item Ha $E(\mathbf{x}) > E(\mathbf{x}_0) $, akkor $\mathbf{x}_0' \equiv \mathbf{x}$
		\item egyébként $\displaystyle p = \exp\left(\dfrac{E(\mathbf{x}) - E(\mathbf{x}_0)}{T}\right)$ valószínűséggel $\mathbf{x}_0' \equiv \mathbf{x}$, különben $\mathbf{x}_0' \equiv \mathbf{x}_0$
	\end{itemize}
	\item Elölről kezdjük $\mathbf{x}_0'$ kezdőponttal
\end{enumerate} %\\~\\
Eközben a hőmérsékletet lassan csökkentjük.

Két határesetet érdemes megvizsgálni: a $T \rightarrow \infty$ (magas hőmérséklet) és a $T \rightarrow 0$ (alacsony hőmérséklet) esetet. Az exponenciális kitevőjében mindig egy negatív szám áll, ezért ha $T \rightarrow \infty$, akkor $p \rightarrow 1$, ha pedig $T \rightarrow 0$, akkor $p \rightarrow 0$.
Emiatt a kezdeti magas hőmérsékleten az algoritmus be tudja járni a paraméterteret, mert szinte biztosan rosszabb sikerességű helyre is mehet. Azonban a hőmérséklet lassú csökkentésével egyre kisebb az esély, hogy alacsonyabb függvényértékű helyre kerül a program. Zéró hőmérséklethez tartva pedig már csak a jobb megoldások felé mozdul el a program. A módszer működését \aref{fig:simulated_annealing_szemleltetes}. ábra szemlélteti.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/sa.png}
	\caption{Szimulált hűtés szemléltetése egy dimenzióban (forrás: \cite{simulated_annealing_fig})}
	\label{fig:simulated_annealing_szemleltetes}
\end{figure}

\Aref{veletlen_kozeli_pont}. lépésben említett közeli pont sokféleképpen értelmezhető, problémafüggő a választás. Legegyszerűbb ha a paramétertérben egy véletlenszerű irányban elmozdulunk egységnyit, a későbbiekben ezt használtuk.

Az, hogy a hőmérséklet időfüggését, hogyan választjuk meg nagyban függ az adott feladattól, a kezdő- és véghőmérséklet pedig a $\Delta E = E(\mathbf{x}) - E(\mathbf{x}_0)$ érték tipikus nagyságrendjétől (egy százalék változás $\Delta E = 0,01$-et jelent). %TODO: ez nálunk...
Esetünkben a kezdőhőmérsékletet $0,01$-nek választottuk, majd minden kiértékelés után csökkentettük úgy, hogy lineárisan elérje a nullát. Ekkor a bemenő paraméter a kiértékelések száma, amelynek sebességével állítani tudjuk a hűtés sebességét, minél nagyobb ez a szám, annál lassabb a folyamat.

A szimulált hűtés várhatóan a sok dimenziós problémákra nem működik olyan jól vagy lassan optimalizál, hiszen a paraméterteret nehezebb, lassabb bejárni, mint egydimenziós esetben. % TODO: görbe illesztésre használják?

\subsection{Genetikus algoritmus}
A genetikus algoritmus \cite{whitley1994genetic} egy evolúció által ihlettett optimalizációs módszer. Ez alatt azt kell érteni, hogy úgy próbál elérni egy optimumot, mint ahogy a természetben az élővilág fejlődik. Ehhez szükséges egy populáció, azaz egyének sokasága. Az egyén egy vektornak felel meg a paramétertérben. A következő három operátor tudja alakítani, változtatni a populációt:
\begin{itemize}
	\item Keresztezés
	\item Mutáció
	\item Szelekció
\end{itemize}
A kezdő populációt véletlenszerűen generált egyénekből hozzuk létre. Jelen esetben a véletlenszerűség azt jelenti, hogy minden paramétert egyenletes eloszlással,  0 és 5 közötti értékkel töltünk fel. Ezután elvégezzük a keresztezést, azaz egy-egy egyén tulajdonságait valamilyen szabály alapján összefésüljük, melyből egy új keletkezik. A két egyént szülőnek a létrejött egyént utódnak nevezzük. Az, hogy a szülők tulajdonságai alapján hogyan hozzuk létre az utód tulajdonságait sokféleképpen lehetséges, viszont implementálás során a legegyszerűbbet választottuk, mégpedig hogy az utód az egyes tulajdonságokat (paramétereket) 50-50 \% eséllyel az egyik vagy másik szülőtől kapja. Páros populációméret esetén a keresztezést úgy végezzük el, hogy minden egyénnek legyen párja, viszont a választás teljesen véletlenszerű legyen. Ezáltal a populáció mérete másfél-szeresére nő.

Miután elvégeztük a keresztezést szelekciót hajtunk végre, amely hasonló az evolúció esetén történő természetes kiválasztódáshoz. Először az összes egyedre kiszámítjuk az $E(\mathbf{p})$ sikerességi hányadost, ezeket sorba rendezzük a függvény értéke szerint, majd a legjobbakat kiválasztjuk, a többit pedig eldobjuk. Érdemes annyi egyedet kiválasztani, mint amennyi a populáció kezdő mérete volt, így az algoritmus futási ideje kiszámítható marad. A kiválasztott egyedek alkotják a következő generációt. A megállási feltétel lehet olyan, hogy az utolsó néhány generáció legjobb egyedeit figyelve már nem tapasztalunk javulást, vagy lehet egyszerűen egy fix generációszámmal meghatározni. Az egyszerűség kedvéért az utóbbit alkalmazzuk.

Ha csak a keresztezést és szelekciót alkalmazzuk egy olyan probléma állhat fent, hogy a paraméterteret nem járjuk be csak egy kis tartományon. Ez az optimalizáció hatékonyságát csökkenti. Úgy tehetünk ellene, ha minden generáció esetében az egyedek egy részét kicsivel megváltoztatjuk, ezt a műveletet mutációnak nevezzük. Gyakorlatban az összes egyed, összes tulajdonságát egy bizonyos valószínűséggel megváltoztatjuk. A változás alatt azt értjük, hogy az eredeti értékhez hozzáadunk egy $0,5$ szórású, $0$ várható értékű normális eloszlású változót. % TODO: változó? 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{img/crossover_mutation.png}
	\caption{Keresztezés és mutáció szemléltetése (forrás: \cite{genetic_cross-mutation})}
	\label{}
\end{figure}

A populáció mérete állítható, általában minél nagyobbat választunk, annál jobb lesz az optimalizáció (bizonyos értékig), viszont figyelembe kell venni a futási időt is, amely arányos a populáció méretével.

A genetikus algoritmust az előző két optimalizációs módszerrel összehasonlítva sokdimenziós paramétertéren is jól működik és nem lokális szélsőértéket talál, hanem egy viszonylag jó optimumot. Nagy előnyt jelent, hogy több megoldást tárol el egyszerre, mert lehet, hogy két teljesen különböző egyed is hasonlóan jó sikerességi hányadosú, mutációval pedig az egyik tökéletesíthető a későbbi generációkban.
\subsection{Kiértékelések száma}
%TODO: talán a kiértékelési idővel összevonva?

\section{Eredmények}
A különböző optimalizációs módszerek eredményeit más-más szempontból lehet vizsgálni. Alapvetően a paramétereket és a hozzájuk tartozó sikerességeket érdemes valahogyan szemléltetni. A módszereket többnyire az 50 ismerősű iWiW-es adatokon próbáltuk ki, mert a kiértékelési idő annál a legkisebb.

\subsection{Gradiens módszer}
A sikerességet ennél a módszernél a lépésszámok függvényében adatjuk meg. \Aref{grad_fix}. ábrán látható egy ilyenfajta ábrázolás.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/grad_fix.eps}
	\caption{Sikeresség az iterációszám függvényében, kezdőpont az optimalizálatlan eset (iWiW 50 ismerős)}
	\label{grad_fix}
\end{figure}
Meg kell jegyezni, hogy a módszer végeredménye nagyban függ a kezdőponttól, hiszen determinisztikus. Megállási feltételt sem egyszerű definiálni, mivel sok lokális minimum van az $E(\mathbf{p})$ függvényben. \Aref{grad_fix}. ábrán is látszik, hogy a kb. 20 és 50 közötti részen sokszor visszaesik a sikeresség értéke, viszont az intervallumon összességében nő $E(\mathbf{p})$ értéke. Ez alapján a megállási feltételt a következőképpen lehetne meghatározni: akkor álljon le az iteráció, amikor az utolsó tíz lépésben nem volt nagyobb érték, mint azelőtt. %TODO: érthető? tíz helyett valami betű konstans?
\subsection{Szimulált hűtés}
A szimulált hűtés esetében a sikerességeket a hőmérséklet függvényében figyelhetjük meg. % TODO: figyelhetjük meg helyett valami más szó
Mivel ez egy sztochasztikus módszer, ezért többszöri futás eredményeit is összevetjük. % TODO: új bekezdés?
Állítható bemenő paraméter a kezdőpont (kezdő paraméterek), illetve az, hogy hány kiértékelés legyen a hűtés során, ezzel a hőmérséklet csökkenésének sebességét változtathatjuk. A kezdő paraméterek a korábban (\ref{parameterek_subsection}. alrészben) optimalizálatlan esetnek nevezett paraméterek. % TODO: érthető??
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/sa_fix_1000_legek.eps}
	\caption{Sikeresség a hőmérséklet függvényében, 1000 kiértékelés, 5 futás közül a legrosszabb (piros) és legjobb (zöld) végeredményű (iWiW 50 ismerős)}
	\label{sa_legek}
\end{figure}
\Aref{sa_legek}. ábrán látható két sikeresség függvény, melyeket a szimulált hűtés ötszöri futtatása után választottunk ki, a legrosszabb és a legjobb végeredményűt. Ebből látszik, hogy mekkora eltérés lehet két futás között, a rosszabb 57,6 \%, a jobb 61,4 \% sikeresség lett. Mindkettőnél megfigyelhető kis hőmérsékleten (kb. $0,6 \cdot 10^{-3}$ alatt) egy szinte vízszintes rész, ez amiatt van, mert ilyen kis hőmérsékleten a módszer szinte már csak a jobb megoldások felé mozdul el.
\subsection{Genetikus algoritmus}
A genetikus algoritmus esetében minden generációban sok egyed van, melyek sikerességét együtt nehéz lenne megjeleníteni, ezért csak az adott generáció legjobb egyedének sikerességét választjuk ki, majd ábrázoljuk.
\begin{figure}[H]
	\centering
	
	\caption{}
	\label{}
\end{figure}

\subsection{Összehasonlítás}
Az optimalizációs módszerek végeredményeit összehasonlíthatjuk, illetve összevethetjük az optimalizálatlan eset sikerességeivel is.
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		 & \multicolumn{4}{|c|}{iWiW} & Telefonos \\
		\hline
		 & 50 & 100 & 200 & 300 & 60-69 \\
		 \hline
		 Optimizálatlan eset & 50,6 \% & 63,8 \% & 77,5 \% & 81,9 \% & 35,4 \% \\
		 \hline
		 Genetikus algoritmus & 61,5 \% & 74,3 \% & 86,7 \% & 89,1 \% & 39,4 \% \\
		 \hline
	\end{tabular}
	\caption{}
\end{table}

\subsection{Optimális paraméterek}
A bemutatott optimalizációs módszerek közül a genetikus algoritmus eredményei voltak stabilan a legjobbak, ezért mindegyik adatbázisra lefuttattuk. Paraméterekként a következőket használtuk: 10-es populációméret, 100 generáció, 25 \%-os mutáció.
\begin{table}[H]
	\centering
	\setstretch{1.5} % [width=1.5cm,height=1.2cm]
	\begin{subtable}{0.49\textwidth}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\diagbox[width=1.5cm,height=1.2cm]{$\sigma_{cs}$}{$n_{cs}$} & $]0;1]$ & $]1;5]$ & $]5;10]$ & $]10;\infty[$  \\
			\hline
			$0$ & 1,14 & \multicolumn{3}{|c|}{3,43} \\
			\hline
			$]0;3]$ & \multicolumn{2}{|c|}{2,14} & 5,88 & 4,85 \\
			\hline
			$]3;6]$ & \multicolumn{2}{|c|}{0,05} & 3,27 & 4,06 \\
			\hline
			$]6;\infty[$  & \multicolumn{2}{|c|}{0,0} & 0,0 & 0,0 \\
			\hline
		\end{tabular}
		\caption{legjobb}
	\end{subtable}
	\begin{subtable}{0.49\textwidth}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\diagbox[width=1.5cm,height=1.2cm]{$\sigma_{cs}$}{$n_{cs}$} & $]0;1]$ & $]1;5]$ & $]5;10]$ & $]10;\infty[$  \\
			\hline
			$0$ & 0,3 & \multicolumn{3}{|c|}{4,79} \\
			\hline
			$]0;3]$ & \multicolumn{2}{|c|}{2,22} & 7,0 & 3,85 \\
			\hline
			$]3;6]$ & \multicolumn{2}{|c|}{0,0} & 0,57 & 3,42 \\
			\hline
			$]6;\infty[$  & \multicolumn{2}{|c|}{1,53} & 0,13 & 0,36 \\
			\hline
		\end{tabular}
		\caption{0.25-ös mutációval a legjobb}
	\end{subtable}
	\caption{iWiW 50 ismerős} % A különböző tartományokban alkalmazott súlyok
\end{table}
\begin{table}[H]
	\centering
	\setstretch{1.5}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\diagbox{$\sigma_{cs}$}{$n_{cs}$} & $]0;1]$ & $]1;5]$ & $]5;10]$ & $]10;\infty[$  \\
		\hline
		$0$ & 0.24 & \multicolumn{3}{|c|}{5.24} \\
		\hline
		$]0;3]$ & \multicolumn{2}{|c|}{2.47} & 9.78 & 5.8 \\
		\hline
		$]3;6]$ & \multicolumn{2}{|c|}{0.0} & 2.2 & 6.11 \\
		\hline
		$]6;\infty[$  & \multicolumn{2}{|c|}{0.28} & 1.07 & 0.0 \\
		\hline
	\end{tabular}
	\caption{A különböző tartományokban alkalmazott súlyok}
\end{table}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/genetic_100pop_mutation_tel.eps}
\end{figure}
\section{Összegzés}

%\renewbibmacro{in:}{}
%\printbibliography[title={Irodalomjegyzék}]
\bibliography{bibliography} % TODO: ISBN?
\end{document}